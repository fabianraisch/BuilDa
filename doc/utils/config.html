<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>src.utils.config API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.utils.config</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.utils.config.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>config_path: <module 'posixpath' (frozen)>,<br>fmu_path: <module 'posixpath' (frozen)>,<br>output_path: <module 'posixpath' (frozen)>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config:
    def __init__(self, 
                 config_path: os.path, 
                 fmu_path: os.path, 
                 output_path: os.path
                 ):
        
        &#39;&#39;&#39; 
        Initialize the Configurator containing the config and other necessary information about the program.

        Args:
            - config_path: The path to the config json file.
            - fmu_path: The path to the fmu.
            - output_path: The path where the output of the simulations will be written to.

        Returns: None
        &#39;&#39;&#39;

        self.START_TIME_DEFAULT = 0.0
        self.STOP_TIME_DEFAULT = 86400
        self.WRITER_STEP_SIZE_DEFAULT = 900
        self.CONTROLLER_STEP_SIZE_DEFAULT = 900

        self.config_path = config_path
        self.fmu_path = fmu_path
        self.output_path = output_path

        self.fmu_name = os.path.split(self.fmu_path)[-1]
        
        # Parse the Config into a python dictionary object.        
        self.config = self.parse_config(load_json(self.config_path))
        
    def get(self, key):
        &#39;&#39;&#39;
        Retrieve a specific configuration parameter by key.

        Args:
            key: The key of the configuration parameter to retrieve.

        Returns:
            The value associated with the specified key.

        Raises:
            KeyError: If the key does not exist in the configuration.
        &#39;&#39;&#39;
        if key in self.config:
            return self.config[key]
        else:
            raise KeyError(f&#34;Given key &#39;{key}&#39; does not exist in the configuration.&#34;)
    

    def parse_config(self, config):

        &#34;&#34;&#34; 
        Function to parse a variation configuration dictionary.

        Arguments:
            config: the variation configuration to parse.

        Returns:
            the parsed variation configuration.
        &#34;&#34;&#34;
        
        # The default parsed configuration.
        parsed = {
            &#34;variations&#34;: {

            },
            &#34;variation_type&#34;: &#34;default&#34;,
            &#34;controller_name&#34;: None,
            &#34;controller_step_size&#34;: self.CONTROLLER_STEP_SIZE_DEFAULT,
            &#34;converter_functions&#34;: [],
            &#34;start_time&#34;: self.START_TIME_DEFAULT,
            &#34;stop_time&#34;: self.STOP_TIME_DEFAULT,        # Equals one day default
            &#34;writer_step_size&#34;: self.WRITER_STEP_SIZE_DEFAULT,        # Equals 15 minutes default
            &#34;columns_included&#34;: [],                      # Default: include all columns
            &#34;time_columns_included&#34;: [&#34;second_of_day&#34;,&#34;day_of_year&#34;]
        }

        # Parse variations
        variations = config.get(&#34;variations&#34;, [])

        # Iterate over each specification to parse each values to a list.
        for variation in variations:
            list_for_perm = []
            if isinstance(variations[variation], list):     # List is already given
                list_for_perm = variations[variation]
            elif isinstance(variations[variation], str):      # List declaration via String
                list_for_perm = self.__parse_variation_string(variations[variation])
            elif isinstance(variations[variation],(float,int)):
                list_for_perm=[variations[variation]]
            else:
                raise ValueError(&#34;malformatted parameter set for &#39;&#34;+variation+&#34;&#39;: &#34;+str(variations[variation])+&#34;  --&gt; should be list, number or special string&#34;)

            parsed[&#34;variations&#34;][variation] = list_for_perm

        # Parse validation_type
        variation_mode = config.get(&#34;variation_type&#34;, &#34;default&#34;)
        parsed[&#34;variation_type&#34;] = variation_mode

        # Parse the controller name
        parsed[&#34;controller_name&#34;] =config.get(&#34;controller_name&#34;, None)

        # Parse the time settings if set in the config
        start_time = config.get(&#34;start_time&#34;, self.START_TIME_DEFAULT)
        if isinstance(start_time, (int, float)):
            parsed[&#34;start_time&#34;] = int(start_time)
        stop_time = config.get(&#34;stop_time&#34;, self.STOP_TIME_DEFAULT)
        if isinstance(stop_time, (int, float)):
            parsed[&#34;stop_time&#34;] = int(stop_time)
        step_size = config.get(&#34;writer_step_size&#34;, self.WRITER_STEP_SIZE_DEFAULT)
        if isinstance(step_size, (int, float)):
            parsed[&#34;writer_step_size&#34;] = int(step_size)

        # Parse Controller step size (needed here because default step size could be used)
        controller_step_size = config.get(&#34;controller_step_size&#34;, self.CONTROLLER_STEP_SIZE_DEFAULT)
        if isinstance(controller_step_size, (int, float)):
            parsed[&#34;controller_step_size&#34;] = int(controller_step_size)
        else:
            parsed[&#34;controller_step_size&#34;] = parsed[&#34;writer_step_size&#34;] # If no controller step size is given, the normal step size is used.

        # Parse converter functions
        converter_functions = config.get(&#34;converter_functions&#34;, None)
        if converter_functions:
            if isinstance(converter_functions, str): converter_functions = [converter_functions]
            parsed[&#34;converter_functions&#34;] = converter_functions

        # Parse columns_included from the config file
        columns_included = config.get(&#34;columns_included&#34;, [])
        if isinstance(columns_included, list):
            parsed[&#34;columns_included&#34;] = columns_included

        # Parse time_columns_included from the config file
        time_columns_included = config.get(&#34;time_columns_included&#34;)
        if isinstance(time_columns_included, list):
            parsed[&#34;time_columns_included&#34;] = time_columns_included



        return parsed
    


    def __parse_variation_string(string):

        &#34;&#34;&#34; 
        Function to parse a variation string.

        Arguments:
            string: the variation string to parse.

        Returns:
            the variation values.

        Currently, there are the following patterns to parse:

        - [a, b, c, d]  -&gt; [a, b, c, d]
        - &#34;r (a, b, r)&#34; -&gt; [a, a+r, a+2r, ..., b] (range function)
        - &#34;s (a, b, step, size) -&gt; takes a sample from the discrete range [a, b] with step size step
        - &#34;c (a, b, decimal_places, size) -&gt; takes a sample from the continuous space [a, b] and rounds it.
        &#34;&#34;&#34;

        nums = list(map(lambda x: int(x), re.findall(r&#39;\d+&#39;, string)))

        if string[0] == &#34;r&#34;:
            if len(nums) != 3:
                return []

            return [x for x in range(int(nums[0]), int(nums[1]) + 1, int(nums[2]))]

        elif string[0] == &#34;s&#34;:
            if len(nums) != 4:
                return []

            if len(list(range(nums[0], nums[1] + 1, nums[2]))) &gt;= nums[3]:  # Size greater than amount of samples.
                return list(range(nums[0], nums[1] + 1, nums[2]))

            return random.sample(range(nums[0], nums[1] + 1, nums[2]), nums[3])

        elif string[0] == &#34;c&#34;:
            if len(nums) != 4:
                return []

            return [round(random.uniform(nums[0], nums[1]), nums[2]) for _ in range(nums[3])]

        else:
            return []
    

        
    def get_max_permitted_time_step(self):
        &#39;&#39;&#39;
        max_permitted_time_step (int): This parameter defines the maximum allowable 
        time step, expressed in seconds, that is consistent with the resolution 
        of the external input files. It ensures that the time intervals between 
        solver steps do not exceed this threshold, thereby ensuring, that all 
        events defined by the external input files are seen by the model. 
        In contrast to writer_step_size, it doesn&#39;t affect the the ability for events
        to be seen by the user in the results.

        Function calculates this max_permitted_time_step, considered are files with changes in data (at least two different values in data), that are supposed to affect the dynamics in the model
        
        &#39;&#39;&#39;

        df_hygienicalWindowOpening=load_hygienicalWindowOpening_data(self.config[&#34;variations&#34;])
        df_internalGain=load_internalGain_data(self.config[&#34;variations&#34;])
        df_weather=load_weather_data(self.config[&#34;variations&#34;])
        
        #get time step of external profiles who have different values in its data
        time_steps_to_consider=[df.index.diff().min().total_seconds() for df in  
                [df_hygienicalWindowOpening, df_internalGain, df_weather] if df.nunique().max().item()&gt;1]

        time_steps_to_consider.append(np.inf)  #set dummy value, if time_steps_to_consider is empty (will do nothing)
        max_permitted_time_step=int(min(time_steps_to_consider))
        return(max_permitted_time_step)</code></pre>
</details>
<div class="desc"><p>Initialize the Configurator containing the config and other necessary information about the program.</p>
<h2 id="args">Args</h2>
<ul>
<li>config_path: The path to the config json file.</li>
<li>fmu_path: The path to the fmu.</li>
<li>output_path: The path where the output of the simulations will be written to.
Returns: None</li>
</ul></div>
<h3>Methods</h3>
<dl>
<dt id="src.utils.config.Config.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key):
    &#39;&#39;&#39;
    Retrieve a specific configuration parameter by key.

    Args:
        key: The key of the configuration parameter to retrieve.

    Returns:
        The value associated with the specified key.

    Raises:
        KeyError: If the key does not exist in the configuration.
    &#39;&#39;&#39;
    if key in self.config:
        return self.config[key]
    else:
        raise KeyError(f&#34;Given key &#39;{key}&#39; does not exist in the configuration.&#34;)</code></pre>
</details>
<div class="desc"><p>Retrieve a specific configuration parameter by key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>The key of the configuration parameter to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value associated with the specified key.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>If the key does not exist in the configuration.</dd>
</dl></div>
</dd>
<dt id="src.utils.config.Config.get_max_permitted_time_step"><code class="name flex">
<span>def <span class="ident">get_max_permitted_time_step</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_permitted_time_step(self):
    &#39;&#39;&#39;
    max_permitted_time_step (int): This parameter defines the maximum allowable 
    time step, expressed in seconds, that is consistent with the resolution 
    of the external input files. It ensures that the time intervals between 
    solver steps do not exceed this threshold, thereby ensuring, that all 
    events defined by the external input files are seen by the model. 
    In contrast to writer_step_size, it doesn&#39;t affect the the ability for events
    to be seen by the user in the results.

    Function calculates this max_permitted_time_step, considered are files with changes in data (at least two different values in data), that are supposed to affect the dynamics in the model
    
    &#39;&#39;&#39;

    df_hygienicalWindowOpening=load_hygienicalWindowOpening_data(self.config[&#34;variations&#34;])
    df_internalGain=load_internalGain_data(self.config[&#34;variations&#34;])
    df_weather=load_weather_data(self.config[&#34;variations&#34;])
    
    #get time step of external profiles who have different values in its data
    time_steps_to_consider=[df.index.diff().min().total_seconds() for df in  
            [df_hygienicalWindowOpening, df_internalGain, df_weather] if df.nunique().max().item()&gt;1]

    time_steps_to_consider.append(np.inf)  #set dummy value, if time_steps_to_consider is empty (will do nothing)
    max_permitted_time_step=int(min(time_steps_to_consider))
    return(max_permitted_time_step)</code></pre>
</details>
<div class="desc"><p>max_permitted_time_step (int): This parameter defines the maximum allowable
time step, expressed in seconds, that is consistent with the resolution
of the external input files. It ensures that the time intervals between
solver steps do not exceed this threshold, thereby ensuring, that all
events defined by the external input files are seen by the model.
In contrast to writer_step_size, it doesn't affect the the ability for events
to be seen by the user in the results.</p>
<p>Function calculates this max_permitted_time_step, considered are files with changes in data (at least two different values in data), that are supposed to affect the dynamics in the model</p></div>
</dd>
<dt id="src.utils.config.Config.parse_config"><code class="name flex">
<span>def <span class="ident">parse_config</span></span>(<span>self, config)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_config(self, config):

    &#34;&#34;&#34; 
    Function to parse a variation configuration dictionary.

    Arguments:
        config: the variation configuration to parse.

    Returns:
        the parsed variation configuration.
    &#34;&#34;&#34;
    
    # The default parsed configuration.
    parsed = {
        &#34;variations&#34;: {

        },
        &#34;variation_type&#34;: &#34;default&#34;,
        &#34;controller_name&#34;: None,
        &#34;controller_step_size&#34;: self.CONTROLLER_STEP_SIZE_DEFAULT,
        &#34;converter_functions&#34;: [],
        &#34;start_time&#34;: self.START_TIME_DEFAULT,
        &#34;stop_time&#34;: self.STOP_TIME_DEFAULT,        # Equals one day default
        &#34;writer_step_size&#34;: self.WRITER_STEP_SIZE_DEFAULT,        # Equals 15 minutes default
        &#34;columns_included&#34;: [],                      # Default: include all columns
        &#34;time_columns_included&#34;: [&#34;second_of_day&#34;,&#34;day_of_year&#34;]
    }

    # Parse variations
    variations = config.get(&#34;variations&#34;, [])

    # Iterate over each specification to parse each values to a list.
    for variation in variations:
        list_for_perm = []
        if isinstance(variations[variation], list):     # List is already given
            list_for_perm = variations[variation]
        elif isinstance(variations[variation], str):      # List declaration via String
            list_for_perm = self.__parse_variation_string(variations[variation])
        elif isinstance(variations[variation],(float,int)):
            list_for_perm=[variations[variation]]
        else:
            raise ValueError(&#34;malformatted parameter set for &#39;&#34;+variation+&#34;&#39;: &#34;+str(variations[variation])+&#34;  --&gt; should be list, number or special string&#34;)

        parsed[&#34;variations&#34;][variation] = list_for_perm

    # Parse validation_type
    variation_mode = config.get(&#34;variation_type&#34;, &#34;default&#34;)
    parsed[&#34;variation_type&#34;] = variation_mode

    # Parse the controller name
    parsed[&#34;controller_name&#34;] =config.get(&#34;controller_name&#34;, None)

    # Parse the time settings if set in the config
    start_time = config.get(&#34;start_time&#34;, self.START_TIME_DEFAULT)
    if isinstance(start_time, (int, float)):
        parsed[&#34;start_time&#34;] = int(start_time)
    stop_time = config.get(&#34;stop_time&#34;, self.STOP_TIME_DEFAULT)
    if isinstance(stop_time, (int, float)):
        parsed[&#34;stop_time&#34;] = int(stop_time)
    step_size = config.get(&#34;writer_step_size&#34;, self.WRITER_STEP_SIZE_DEFAULT)
    if isinstance(step_size, (int, float)):
        parsed[&#34;writer_step_size&#34;] = int(step_size)

    # Parse Controller step size (needed here because default step size could be used)
    controller_step_size = config.get(&#34;controller_step_size&#34;, self.CONTROLLER_STEP_SIZE_DEFAULT)
    if isinstance(controller_step_size, (int, float)):
        parsed[&#34;controller_step_size&#34;] = int(controller_step_size)
    else:
        parsed[&#34;controller_step_size&#34;] = parsed[&#34;writer_step_size&#34;] # If no controller step size is given, the normal step size is used.

    # Parse converter functions
    converter_functions = config.get(&#34;converter_functions&#34;, None)
    if converter_functions:
        if isinstance(converter_functions, str): converter_functions = [converter_functions]
        parsed[&#34;converter_functions&#34;] = converter_functions

    # Parse columns_included from the config file
    columns_included = config.get(&#34;columns_included&#34;, [])
    if isinstance(columns_included, list):
        parsed[&#34;columns_included&#34;] = columns_included

    # Parse time_columns_included from the config file
    time_columns_included = config.get(&#34;time_columns_included&#34;)
    if isinstance(time_columns_included, list):
        parsed[&#34;time_columns_included&#34;] = time_columns_included



    return parsed</code></pre>
</details>
<div class="desc"><p>Function to parse a variation configuration dictionary.</p>
<h2 id="arguments">Arguments</h2>
<p>config: the variation configuration to parse.</p>
<h2 id="returns">Returns</h2>
<p>the parsed variation configuration.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.utils" href="index.html">src.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.utils.config.Config" href="#src.utils.config.Config">Config</a></code></h4>
<ul class="">
<li><code><a title="src.utils.config.Config.get" href="#src.utils.config.Config.get">get</a></code></li>
<li><code><a title="src.utils.config.Config.get_max_permitted_time_step" href="#src.utils.config.Config.get_max_permitted_time_step">get_max_permitted_time_step</a></code></li>
<li><code><a title="src.utils.config.Config.parse_config" href="#src.utils.config.Config.parse_config">parse_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
